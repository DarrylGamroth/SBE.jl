# Generated SBE (Simple Binary Encoding) message codec
# Code generated by SBE. DO NOT EDIT.

export TokenCodec, TokenCodecDecoder, TokenCodecEncoder
abstract type TokenCodec{T} end

struct TokenCodecDecoder{T<:AbstractArray{UInt8}} <: TokenCodec{T}
    buffer::T
    offset::Int64
    position_ptr::SBE.PositionPointer
    acting_block_length::UInt16
    acting_version::UInt16
    function TokenCodecDecoder(buffer::T, offset::Integer, position_ptr::SBE.PositionPointer,
        acting_block_length::Integer, acting_version::Integer) where {T}
        position_ptr[] = offset + acting_block_length
        new{T}(buffer, offset, position_ptr, acting_block_length, acting_version)
    end
end

struct TokenCodecEncoder{T<:AbstractArray{UInt8},HasSbeHeader} <: TokenCodec{T}
    buffer::T
    offset::Int64
    position_ptr::SBE.PositionPointer
    function TokenCodecEncoder(buffer::T, offset::Integer,
        position_ptr::SBE.PositionPointer, hasSbeHeader::Bool=false) where {T}
        position_ptr[] = offset + 28
        new{T,hasSbeHeader}(buffer, offset, position_ptr)
    end
end

@inline function TokenCodecDecoder(buffer::AbstractArray, offset::Integer=0;
    position_ptr::SBE.PositionPointer=SBE.PositionPointer(),
    header::MessageHeader=MessageHeader(buffer, offset))
    if templateId(header) != UInt16(0x2) || schemaId(header) != UInt16(0x1)
        throw(DomainError("Template id or schema id mismatch"))
    end
    TokenCodecDecoder(buffer, offset + sbe_encoded_length(header), position_ptr,
        blockLength(header), version(header))
end
@inline function TokenCodecEncoder(buffer::AbstractArray, offset::Integer=0;
    position_ptr::SBE.PositionPointer=SBE.PositionPointer(),
    header::MessageHeader=MessageHeader(buffer, offset))
    blockLength!(header, UInt16(0x1c))
    templateId!(header, UInt16(0x2))
    schemaId!(header, UInt16(0x1))
    version!(header, UInt16(0x0))
    TokenCodecEncoder(buffer, offset + sbe_encoded_length(header), position_ptr, true)
end
sbe_buffer(m::TokenCodec) = m.buffer
sbe_offset(m::TokenCodec) = m.offset
sbe_position_ptr(m::TokenCodec) = m.position_ptr
sbe_position(m::TokenCodec) = m.position_ptr[]
sbe_position!(m::TokenCodec, position) = m.position_ptr[] = position
sbe_block_length(::TokenCodec) = UInt16(0x1c)
sbe_block_length(::Type{<:TokenCodec}) = UInt16(0x1c)
sbe_template_id(::TokenCodec) = UInt16(0x2)
sbe_template_id(::Type{<:TokenCodec})  = UInt16(0x2)
sbe_schema_id(::TokenCodec) = UInt16(0x1)
sbe_schema_id(::Type{<:TokenCodec})  = UInt16(0x1)
sbe_schema_version(::TokenCodec) = UInt16(0x0)
sbe_schema_version(::Type{<:TokenCodec})  = UInt16(0x0)
sbe_semantic_type(::TokenCodec) = ""
sbe_semantic_version(::TokenCodec) = ""
sbe_acting_block_length(m::TokenCodecDecoder) = m.acting_block_length
sbe_acting_block_length(::TokenCodecEncoder) = UInt16(0x1c)
sbe_acting_version(m::TokenCodecDecoder) = m.acting_version
sbe_acting_version(::TokenCodecEncoder) = UInt16(0x0)
sbe_rewind!(m::TokenCodec) = sbe_position!(m, m.offset + sbe_acting_block_length(m))
sbe_encoded_length(m::TokenCodec) = sbe_position(m) - m.offset
@inline function sbe_decoded_length(m::TokenCodec)
    skipper = TokenCodecDecoder(sbe_buffer(m), sbe_offset(m), SBE.PositionPointer(),
        sbe_acting_block_length(m), sbe_acting_version(m))
    sbe_skip!(skipper)
    sbe_encoded_length(skipper)
end

Base.sizeof(m::TokenCodec) = sbe_decoded_length(m)
function Base.convert(::Type{AbstractArray{UInt8}}, m::TokenCodecEncoder{<:AbstractArray{UInt8},true})
    return view(m.buffer, m.offset+1-sbe_encoded_length(MessageHeader):m.offset+sbe_encoded_length(m))
end
function Base.convert(::Type{AbstractArray{UInt8}}, m::TokenCodecEncoder{<:AbstractArray{UInt8},false})
    return view(m.buffer, m.offset+1:m.offset+sbe_encoded_length(m))
end

function tokenOffset_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
tokenOffset_id(::TokenCodec) = UInt16(0x1)
tokenOffset_id(::Type{<:TokenCodec}) = UInt16(0x1)
tokenOffset_since_version(::TokenCodec) = UInt16(0x0)
tokenOffset_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
tokenOffset_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
tokenOffset_encoding_offset(::TokenCodec) = 0
tokenOffset_encoding_offset(::Type{<:TokenCodec}) = 0
tokenOffset_null_value(::TokenCodec) = Int32(-2147483648)
tokenOffset_null_value(::Type{<:TokenCodec}) = Int32(-2147483648)
tokenOffset_min_value(::TokenCodec) = Int32(-2147483647)
tokenOffset_min_value(::Type{<:TokenCodec}) = Int32(-2147483647)
tokenOffset_max_value(::TokenCodec) = Int32(2147483647)
tokenOffset_max_value(::Type{<:TokenCodec}) = Int32(2147483647)
tokenOffset_encoding_length(::TokenCodec) = 4
tokenOffset_encoding_length(::Type{<:TokenCodec}) = 4

@inline function tokenOffset(m::TokenCodecDecoder)
    return decode_le(Int32, m.buffer, m.offset + 0)
end
@inline tokenOffset!(m::TokenCodecEncoder, value) = encode_le(Int32, m.buffer, m.offset + 0, value)

function tokenSize_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
tokenSize_id(::TokenCodec) = UInt16(0x2)
tokenSize_id(::Type{<:TokenCodec}) = UInt16(0x2)
tokenSize_since_version(::TokenCodec) = UInt16(0x0)
tokenSize_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
tokenSize_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
tokenSize_encoding_offset(::TokenCodec) = 4
tokenSize_encoding_offset(::Type{<:TokenCodec}) = 4
tokenSize_null_value(::TokenCodec) = Int32(-2147483648)
tokenSize_null_value(::Type{<:TokenCodec}) = Int32(-2147483648)
tokenSize_min_value(::TokenCodec) = Int32(-2147483647)
tokenSize_min_value(::Type{<:TokenCodec}) = Int32(-2147483647)
tokenSize_max_value(::TokenCodec) = Int32(2147483647)
tokenSize_max_value(::Type{<:TokenCodec}) = Int32(2147483647)
tokenSize_encoding_length(::TokenCodec) = 4
tokenSize_encoding_length(::Type{<:TokenCodec}) = 4

@inline function tokenSize(m::TokenCodecDecoder)
    return decode_le(Int32, m.buffer, m.offset + 4)
end
@inline tokenSize!(m::TokenCodecEncoder, value) = encode_le(Int32, m.buffer, m.offset + 4, value)

function fieldId_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
fieldId_id(::TokenCodec) = UInt16(0x3)
fieldId_id(::Type{<:TokenCodec}) = UInt16(0x3)
fieldId_since_version(::TokenCodec) = UInt16(0x0)
fieldId_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
fieldId_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
fieldId_encoding_offset(::TokenCodec) = 8
fieldId_encoding_offset(::Type{<:TokenCodec}) = 8
fieldId_null_value(::TokenCodec) = Int32(-2147483648)
fieldId_null_value(::Type{<:TokenCodec}) = Int32(-2147483648)
fieldId_min_value(::TokenCodec) = Int32(-2147483647)
fieldId_min_value(::Type{<:TokenCodec}) = Int32(-2147483647)
fieldId_max_value(::TokenCodec) = Int32(2147483647)
fieldId_max_value(::Type{<:TokenCodec}) = Int32(2147483647)
fieldId_encoding_length(::TokenCodec) = 4
fieldId_encoding_length(::Type{<:TokenCodec}) = 4

@inline function fieldId(m::TokenCodecDecoder)
    return decode_le(Int32, m.buffer, m.offset + 8)
end
@inline fieldId!(m::TokenCodecEncoder, value) = encode_le(Int32, m.buffer, m.offset + 8, value)

function tokenVersion_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
tokenVersion_id(::TokenCodec) = UInt16(0x4)
tokenVersion_id(::Type{<:TokenCodec}) = UInt16(0x4)
tokenVersion_since_version(::TokenCodec) = UInt16(0x0)
tokenVersion_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
tokenVersion_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
tokenVersion_encoding_offset(::TokenCodec) = 12
tokenVersion_encoding_offset(::Type{<:TokenCodec}) = 12
tokenVersion_null_value(::TokenCodec) = Int32(-2147483648)
tokenVersion_null_value(::Type{<:TokenCodec}) = Int32(-2147483648)
tokenVersion_min_value(::TokenCodec) = Int32(-2147483647)
tokenVersion_min_value(::Type{<:TokenCodec}) = Int32(-2147483647)
tokenVersion_max_value(::TokenCodec) = Int32(2147483647)
tokenVersion_max_value(::Type{<:TokenCodec}) = Int32(2147483647)
tokenVersion_encoding_length(::TokenCodec) = 4
tokenVersion_encoding_length(::Type{<:TokenCodec}) = 4

@inline function tokenVersion(m::TokenCodecDecoder)
    return decode_le(Int32, m.buffer, m.offset + 12)
end
@inline tokenVersion!(m::TokenCodecEncoder, value) = encode_le(Int32, m.buffer, m.offset + 12, value)

function componentTokenCount_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
componentTokenCount_id(::TokenCodec) = UInt16(0x5)
componentTokenCount_id(::Type{<:TokenCodec}) = UInt16(0x5)
componentTokenCount_since_version(::TokenCodec) = UInt16(0x0)
componentTokenCount_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
componentTokenCount_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
componentTokenCount_encoding_offset(::TokenCodec) = 16
componentTokenCount_encoding_offset(::Type{<:TokenCodec}) = 16
componentTokenCount_null_value(::TokenCodec) = Int32(-2147483648)
componentTokenCount_null_value(::Type{<:TokenCodec}) = Int32(-2147483648)
componentTokenCount_min_value(::TokenCodec) = Int32(-2147483647)
componentTokenCount_min_value(::Type{<:TokenCodec}) = Int32(-2147483647)
componentTokenCount_max_value(::TokenCodec) = Int32(2147483647)
componentTokenCount_max_value(::Type{<:TokenCodec}) = Int32(2147483647)
componentTokenCount_encoding_length(::TokenCodec) = 4
componentTokenCount_encoding_length(::Type{<:TokenCodec}) = 4

@inline function componentTokenCount(m::TokenCodecDecoder)
    return decode_le(Int32, m.buffer, m.offset + 16)
end
@inline componentTokenCount!(m::TokenCodecEncoder, value) = encode_le(Int32, m.buffer, m.offset + 16, value)

function signal_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
signal_id(::TokenCodec) = UInt16(0x6)
signal_id(::Type{<:TokenCodec}) = UInt16(0x6)
signal_since_version(::TokenCodec) = UInt16(0x0)
signal_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
signal_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
signal_encoding_offset(::TokenCodec) = 20
signal_encoding_offset(::Type{<:TokenCodec}) = 20
signal_encoding_length(::TokenCodec) = 1
signal_encoding_length(::Type{<:TokenCodec}) = 1
@inline function signal(m::TokenCodecDecoder, ::Type{Integer})
    return decode_le(UInt8, m.buffer, m.offset + 20)
end
@inline function signal(m::TokenCodecDecoder)
    return SignalCodec.SbeEnum(decode_le(UInt8, m.buffer, m.offset + 20))
end
@inline signal!(m::TokenCodecEncoder, value::SignalCodec.SbeEnum) = encode_le(UInt8, m.buffer, m.offset + 20, UInt8(value))

function primitiveType_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
primitiveType_id(::TokenCodec) = UInt16(0x7)
primitiveType_id(::Type{<:TokenCodec}) = UInt16(0x7)
primitiveType_since_version(::TokenCodec) = UInt16(0x0)
primitiveType_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
primitiveType_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
primitiveType_encoding_offset(::TokenCodec) = 21
primitiveType_encoding_offset(::Type{<:TokenCodec}) = 21
primitiveType_encoding_length(::TokenCodec) = 1
primitiveType_encoding_length(::Type{<:TokenCodec}) = 1
@inline function primitiveType(m::TokenCodecDecoder, ::Type{Integer})
    return decode_le(UInt8, m.buffer, m.offset + 21)
end
@inline function primitiveType(m::TokenCodecDecoder)
    return PrimitiveTypeCodec.SbeEnum(decode_le(UInt8, m.buffer, m.offset + 21))
end
@inline primitiveType!(m::TokenCodecEncoder, value::PrimitiveTypeCodec.SbeEnum) = encode_le(UInt8, m.buffer, m.offset + 21, UInt8(value))

function byteOrder_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
byteOrder_id(::TokenCodec) = UInt16(0x8)
byteOrder_id(::Type{<:TokenCodec}) = UInt16(0x8)
byteOrder_since_version(::TokenCodec) = UInt16(0x0)
byteOrder_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
byteOrder_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
byteOrder_encoding_offset(::TokenCodec) = 22
byteOrder_encoding_offset(::Type{<:TokenCodec}) = 22
byteOrder_encoding_length(::TokenCodec) = 1
byteOrder_encoding_length(::Type{<:TokenCodec}) = 1
@inline function byteOrder(m::TokenCodecDecoder, ::Type{Integer})
    return decode_le(UInt8, m.buffer, m.offset + 22)
end
@inline function byteOrder(m::TokenCodecDecoder)
    return ByteOrderCodec.SbeEnum(decode_le(UInt8, m.buffer, m.offset + 22))
end
@inline byteOrder!(m::TokenCodecEncoder, value::ByteOrderCodec.SbeEnum) = encode_le(UInt8, m.buffer, m.offset + 22, UInt8(value))

function presence_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
presence_id(::TokenCodec) = UInt16(0x9)
presence_id(::Type{<:TokenCodec}) = UInt16(0x9)
presence_since_version(::TokenCodec) = UInt16(0x0)
presence_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
presence_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
presence_encoding_offset(::TokenCodec) = 23
presence_encoding_offset(::Type{<:TokenCodec}) = 23
presence_encoding_length(::TokenCodec) = 1
presence_encoding_length(::Type{<:TokenCodec}) = 1
@inline function presence(m::TokenCodecDecoder, ::Type{Integer})
    return decode_le(UInt8, m.buffer, m.offset + 23)
end
@inline function presence(m::TokenCodecDecoder)
    return PresenceCodec.SbeEnum(decode_le(UInt8, m.buffer, m.offset + 23))
end
@inline presence!(m::TokenCodecEncoder, value::PresenceCodec.SbeEnum) = encode_le(UInt8, m.buffer, m.offset + 23, UInt8(value))

function deprecated_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("optional")
    return Symbol("")
end
deprecated_id(::TokenCodec) = UInt16(0xa)
deprecated_id(::Type{<:TokenCodec}) = UInt16(0xa)
deprecated_since_version(::TokenCodec) = UInt16(0x0)
deprecated_since_version(::Type{<:TokenCodec}) = UInt16(0x0)
deprecated_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= UInt16(0x0)
deprecated_encoding_offset(::TokenCodec) = 24
deprecated_encoding_offset(::Type{<:TokenCodec}) = 24
deprecated_null_value(::TokenCodec) = Int32(0)
deprecated_null_value(::Type{<:TokenCodec}) = Int32(0)
deprecated_min_value(::TokenCodec) = Int32(-2147483647)
deprecated_min_value(::Type{<:TokenCodec}) = Int32(-2147483647)
deprecated_max_value(::TokenCodec) = Int32(2147483647)
deprecated_max_value(::Type{<:TokenCodec}) = Int32(2147483647)
deprecated_encoding_length(::TokenCodec) = 4
deprecated_encoding_length(::Type{<:TokenCodec}) = 4

@inline function deprecated(m::TokenCodecDecoder)
    return decode_le(Int32, m.buffer, m.offset + 24)
end
@inline deprecated!(m::TokenCodecEncoder, value) = encode_le(Int32, m.buffer, m.offset + 24, value)

function name_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

name_character_encoding(::TokenCodec) = "UTF-8"
name_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
name_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
name_id(::TokenCodec) = 11
name_id(::Type{<:TokenCodec}) = 11
name_header_length(::TokenCodec) = 2
name_header_length(::Type{<:TokenCodec}) = 2

@inline function name_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function name_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_name!(m::TokenCodecDecoder)
    len = name_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function name(m::TokenCodecDecoder)
    len = name_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline name(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, name(m))
@inline name(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, name(m)); ntuple(i -> x[i], Val(N)))
@inline name(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(name(m)))
@inline name(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(name(m, StringView))
@inline name(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, name(m))[]
@inline name(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_name!(m); nothing)

@inline function name_buffer!(m::TokenCodecEncoder, len)
    name_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function name!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    name_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function name!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    name_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function name!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    name_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline name!(m::TokenCodecEncoder, src::Symbol) = name!(m, to_string(src))
@inline name!(m::TokenCodecEncoder, src::StaticString) = name!(m, Tuple(src))
@inline name!(m::TokenCodecEncoder, src::Real) = name!(m, Tuple(src))
@inline name!(m::TokenCodecEncoder, ::Nothing) = name_buffer!(m, 0)

function constValue_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

constValue_character_encoding(::TokenCodec) = "UTF-8"
constValue_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
constValue_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
constValue_id(::TokenCodec) = 12
constValue_id(::Type{<:TokenCodec}) = 12
constValue_header_length(::TokenCodec) = 2
constValue_header_length(::Type{<:TokenCodec}) = 2

@inline function constValue_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function constValue_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_constValue!(m::TokenCodecDecoder)
    len = constValue_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function constValue(m::TokenCodecDecoder)
    len = constValue_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline constValue(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, constValue(m))
@inline constValue(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, constValue(m)); ntuple(i -> x[i], Val(N)))
@inline constValue(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(constValue(m)))
@inline constValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(constValue(m, StringView))
@inline constValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, constValue(m))[]
@inline constValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_constValue!(m); nothing)

@inline function constValue_buffer!(m::TokenCodecEncoder, len)
    constValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function constValue!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    constValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function constValue!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    constValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function constValue!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    constValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline constValue!(m::TokenCodecEncoder, src::Symbol) = constValue!(m, to_string(src))
@inline constValue!(m::TokenCodecEncoder, src::StaticString) = constValue!(m, Tuple(src))
@inline constValue!(m::TokenCodecEncoder, src::Real) = constValue!(m, Tuple(src))
@inline constValue!(m::TokenCodecEncoder, ::Nothing) = constValue_buffer!(m, 0)

function minValue_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

minValue_character_encoding(::TokenCodec) = "UTF-8"
minValue_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
minValue_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
minValue_id(::TokenCodec) = 13
minValue_id(::Type{<:TokenCodec}) = 13
minValue_header_length(::TokenCodec) = 2
minValue_header_length(::Type{<:TokenCodec}) = 2

@inline function minValue_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function minValue_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_minValue!(m::TokenCodecDecoder)
    len = minValue_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function minValue(m::TokenCodecDecoder)
    len = minValue_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline minValue(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, minValue(m))
@inline minValue(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, minValue(m)); ntuple(i -> x[i], Val(N)))
@inline minValue(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(minValue(m)))
@inline minValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(minValue(m, StringView))
@inline minValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, minValue(m))[]
@inline minValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_minValue!(m); nothing)

@inline function minValue_buffer!(m::TokenCodecEncoder, len)
    minValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function minValue!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    minValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function minValue!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    minValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function minValue!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    minValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline minValue!(m::TokenCodecEncoder, src::Symbol) = minValue!(m, to_string(src))
@inline minValue!(m::TokenCodecEncoder, src::StaticString) = minValue!(m, Tuple(src))
@inline minValue!(m::TokenCodecEncoder, src::Real) = minValue!(m, Tuple(src))
@inline minValue!(m::TokenCodecEncoder, ::Nothing) = minValue_buffer!(m, 0)

function maxValue_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

maxValue_character_encoding(::TokenCodec) = "UTF-8"
maxValue_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
maxValue_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
maxValue_id(::TokenCodec) = 14
maxValue_id(::Type{<:TokenCodec}) = 14
maxValue_header_length(::TokenCodec) = 2
maxValue_header_length(::Type{<:TokenCodec}) = 2

@inline function maxValue_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function maxValue_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_maxValue!(m::TokenCodecDecoder)
    len = maxValue_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function maxValue(m::TokenCodecDecoder)
    len = maxValue_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline maxValue(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, maxValue(m))
@inline maxValue(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, maxValue(m)); ntuple(i -> x[i], Val(N)))
@inline maxValue(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(maxValue(m)))
@inline maxValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(maxValue(m, StringView))
@inline maxValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, maxValue(m))[]
@inline maxValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_maxValue!(m); nothing)

@inline function maxValue_buffer!(m::TokenCodecEncoder, len)
    maxValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function maxValue!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    maxValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function maxValue!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    maxValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function maxValue!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    maxValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline maxValue!(m::TokenCodecEncoder, src::Symbol) = maxValue!(m, to_string(src))
@inline maxValue!(m::TokenCodecEncoder, src::StaticString) = maxValue!(m, Tuple(src))
@inline maxValue!(m::TokenCodecEncoder, src::Real) = maxValue!(m, Tuple(src))
@inline maxValue!(m::TokenCodecEncoder, ::Nothing) = maxValue_buffer!(m, 0)

function nullValue_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

nullValue_character_encoding(::TokenCodec) = "UTF-8"
nullValue_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
nullValue_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
nullValue_id(::TokenCodec) = 15
nullValue_id(::Type{<:TokenCodec}) = 15
nullValue_header_length(::TokenCodec) = 2
nullValue_header_length(::Type{<:TokenCodec}) = 2

@inline function nullValue_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function nullValue_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_nullValue!(m::TokenCodecDecoder)
    len = nullValue_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function nullValue(m::TokenCodecDecoder)
    len = nullValue_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline nullValue(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, nullValue(m))
@inline nullValue(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, nullValue(m)); ntuple(i -> x[i], Val(N)))
@inline nullValue(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(nullValue(m)))
@inline nullValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(nullValue(m, StringView))
@inline nullValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, nullValue(m))[]
@inline nullValue(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_nullValue!(m); nothing)

@inline function nullValue_buffer!(m::TokenCodecEncoder, len)
    nullValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function nullValue!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    nullValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function nullValue!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    nullValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function nullValue!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    nullValue_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline nullValue!(m::TokenCodecEncoder, src::Symbol) = nullValue!(m, to_string(src))
@inline nullValue!(m::TokenCodecEncoder, src::StaticString) = nullValue!(m, Tuple(src))
@inline nullValue!(m::TokenCodecEncoder, src::Real) = nullValue!(m, Tuple(src))
@inline nullValue!(m::TokenCodecEncoder, ::Nothing) = nullValue_buffer!(m, 0)

function characterEncoding_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

characterEncoding_character_encoding(::TokenCodec) = "UTF-8"
characterEncoding_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
characterEncoding_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
characterEncoding_id(::TokenCodec) = 16
characterEncoding_id(::Type{<:TokenCodec}) = 16
characterEncoding_header_length(::TokenCodec) = 2
characterEncoding_header_length(::Type{<:TokenCodec}) = 2

@inline function characterEncoding_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function characterEncoding_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_characterEncoding!(m::TokenCodecDecoder)
    len = characterEncoding_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function characterEncoding(m::TokenCodecDecoder)
    len = characterEncoding_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline characterEncoding(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, characterEncoding(m))
@inline characterEncoding(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, characterEncoding(m)); ntuple(i -> x[i], Val(N)))
@inline characterEncoding(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(characterEncoding(m)))
@inline characterEncoding(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(characterEncoding(m, StringView))
@inline characterEncoding(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, characterEncoding(m))[]
@inline characterEncoding(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_characterEncoding!(m); nothing)

@inline function characterEncoding_buffer!(m::TokenCodecEncoder, len)
    characterEncoding_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function characterEncoding!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    characterEncoding_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function characterEncoding!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    characterEncoding_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function characterEncoding!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    characterEncoding_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline characterEncoding!(m::TokenCodecEncoder, src::Symbol) = characterEncoding!(m, to_string(src))
@inline characterEncoding!(m::TokenCodecEncoder, src::StaticString) = characterEncoding!(m, Tuple(src))
@inline characterEncoding!(m::TokenCodecEncoder, src::Real) = characterEncoding!(m, Tuple(src))
@inline characterEncoding!(m::TokenCodecEncoder, ::Nothing) = characterEncoding_buffer!(m, 0)

function epoch_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

epoch_character_encoding(::TokenCodec) = "UTF-8"
epoch_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
epoch_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
epoch_id(::TokenCodec) = 17
epoch_id(::Type{<:TokenCodec}) = 17
epoch_header_length(::TokenCodec) = 2
epoch_header_length(::Type{<:TokenCodec}) = 2

@inline function epoch_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function epoch_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_epoch!(m::TokenCodecDecoder)
    len = epoch_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function epoch(m::TokenCodecDecoder)
    len = epoch_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline epoch(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, epoch(m))
@inline epoch(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, epoch(m)); ntuple(i -> x[i], Val(N)))
@inline epoch(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(epoch(m)))
@inline epoch(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(epoch(m, StringView))
@inline epoch(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, epoch(m))[]
@inline epoch(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_epoch!(m); nothing)

@inline function epoch_buffer!(m::TokenCodecEncoder, len)
    epoch_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function epoch!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    epoch_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function epoch!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    epoch_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function epoch!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    epoch_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline epoch!(m::TokenCodecEncoder, src::Symbol) = epoch!(m, to_string(src))
@inline epoch!(m::TokenCodecEncoder, src::StaticString) = epoch!(m, Tuple(src))
@inline epoch!(m::TokenCodecEncoder, src::Real) = epoch!(m, Tuple(src))
@inline epoch!(m::TokenCodecEncoder, ::Nothing) = epoch_buffer!(m, 0)

function timeUnit_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

timeUnit_character_encoding(::TokenCodec) = "UTF-8"
timeUnit_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
timeUnit_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
timeUnit_id(::TokenCodec) = 18
timeUnit_id(::Type{<:TokenCodec}) = 18
timeUnit_header_length(::TokenCodec) = 2
timeUnit_header_length(::Type{<:TokenCodec}) = 2

@inline function timeUnit_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function timeUnit_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_timeUnit!(m::TokenCodecDecoder)
    len = timeUnit_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function timeUnit(m::TokenCodecDecoder)
    len = timeUnit_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline timeUnit(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, timeUnit(m))
@inline timeUnit(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, timeUnit(m)); ntuple(i -> x[i], Val(N)))
@inline timeUnit(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(timeUnit(m)))
@inline timeUnit(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(timeUnit(m, StringView))
@inline timeUnit(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, timeUnit(m))[]
@inline timeUnit(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_timeUnit!(m); nothing)

@inline function timeUnit_buffer!(m::TokenCodecEncoder, len)
    timeUnit_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function timeUnit!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    timeUnit_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function timeUnit!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    timeUnit_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function timeUnit!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    timeUnit_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline timeUnit!(m::TokenCodecEncoder, src::Symbol) = timeUnit!(m, to_string(src))
@inline timeUnit!(m::TokenCodecEncoder, src::StaticString) = timeUnit!(m, Tuple(src))
@inline timeUnit!(m::TokenCodecEncoder, src::Real) = timeUnit!(m, Tuple(src))
@inline timeUnit!(m::TokenCodecEncoder, ::Nothing) = timeUnit_buffer!(m, 0)

function semanticType_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

semanticType_character_encoding(::TokenCodec) = "UTF-8"
semanticType_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
semanticType_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
semanticType_id(::TokenCodec) = 19
semanticType_id(::Type{<:TokenCodec}) = 19
semanticType_header_length(::TokenCodec) = 2
semanticType_header_length(::Type{<:TokenCodec}) = 2

@inline function semanticType_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function semanticType_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_semanticType!(m::TokenCodecDecoder)
    len = semanticType_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function semanticType(m::TokenCodecDecoder)
    len = semanticType_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline semanticType(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, semanticType(m))
@inline semanticType(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, semanticType(m)); ntuple(i -> x[i], Val(N)))
@inline semanticType(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(semanticType(m)))
@inline semanticType(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(semanticType(m, StringView))
@inline semanticType(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, semanticType(m))[]
@inline semanticType(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_semanticType!(m); nothing)

@inline function semanticType_buffer!(m::TokenCodecEncoder, len)
    semanticType_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function semanticType!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    semanticType_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function semanticType!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    semanticType_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function semanticType!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    semanticType_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline semanticType!(m::TokenCodecEncoder, src::Symbol) = semanticType!(m, to_string(src))
@inline semanticType!(m::TokenCodecEncoder, src::StaticString) = semanticType!(m, Tuple(src))
@inline semanticType!(m::TokenCodecEncoder, src::Real) = semanticType!(m, Tuple(src))
@inline semanticType!(m::TokenCodecEncoder, ::Nothing) = semanticType_buffer!(m, 0)

function description_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

description_character_encoding(::TokenCodec) = "UTF-8"
description_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
description_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
description_id(::TokenCodec) = 20
description_id(::Type{<:TokenCodec}) = 20
description_header_length(::TokenCodec) = 2
description_header_length(::Type{<:TokenCodec}) = 2

@inline function description_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function description_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_description!(m::TokenCodecDecoder)
    len = description_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function description(m::TokenCodecDecoder)
    len = description_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline description(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, description(m))
@inline description(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, description(m)); ntuple(i -> x[i], Val(N)))
@inline description(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(description(m)))
@inline description(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(description(m, StringView))
@inline description(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, description(m))[]
@inline description(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_description!(m); nothing)

@inline function description_buffer!(m::TokenCodecEncoder, len)
    description_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function description!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    description_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function description!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    description_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function description!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    description_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline description!(m::TokenCodecEncoder, src::Symbol) = description!(m, to_string(src))
@inline description!(m::TokenCodecEncoder, src::StaticString) = description!(m, Tuple(src))
@inline description!(m::TokenCodecEncoder, src::Real) = description!(m, Tuple(src))
@inline description!(m::TokenCodecEncoder, ::Nothing) = description_buffer!(m, 0)

function referencedName_meta_attribute(::TokenCodec, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

referencedName_character_encoding(::TokenCodec) = "UTF-8"
referencedName_character_encoding(::Type{<:TokenCodec}) = "UTF-8"
referencedName_in_acting_version(m::TokenCodec) = sbe_acting_version(m) >= 0
referencedName_id(::TokenCodec) = 21
referencedName_id(::Type{<:TokenCodec}) = 21
referencedName_header_length(::TokenCodec) = 2
referencedName_header_length(::Type{<:TokenCodec}) = 2

@inline function referencedName_length(m::TokenCodec)
    return decode_le(UInt16, m.buffer, sbe_position(m))
end

@inline function referencedName_length!(m::TokenCodecEncoder, n)
    @boundscheck n > 65534 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 2 + n)
    return encode_le(UInt16, m.buffer, sbe_position(m), n)
end

@inline function skip_referencedName!(m::TokenCodecDecoder)
    len = referencedName_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return len
end

@inline function referencedName(m::TokenCodecDecoder)
    len = referencedName_length(m)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline referencedName(m::TokenCodecDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, referencedName(m))
@inline referencedName(m::TokenCodecDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, referencedName(m)); ntuple(i -> x[i], Val(N)))
@inline referencedName(m::TokenCodecDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(referencedName(m)))
@inline referencedName(m::TokenCodecDecoder, ::Type{T}) where {T<:Symbol} = Symbol(referencedName(m, StringView))
@inline referencedName(m::TokenCodecDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, referencedName(m))[]
@inline referencedName(m::TokenCodecDecoder, ::Type{T}) where {T<:Nothing} = (skip_referencedName!(m); nothing)

@inline function referencedName_buffer!(m::TokenCodecEncoder, len)
    referencedName_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function referencedName!(m::TokenCodecEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    referencedName_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function referencedName!(m::TokenCodecEncoder, src::NTuple)
    len = sizeof(src)
    referencedName_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function referencedName!(m::TokenCodecEncoder, src::AbstractString)
    len = sizeof(src)
    referencedName_length!(m, len)
    pos = sbe_position(m) + 2
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline referencedName!(m::TokenCodecEncoder, src::Symbol) = referencedName!(m, to_string(src))
@inline referencedName!(m::TokenCodecEncoder, src::StaticString) = referencedName!(m, Tuple(src))
@inline referencedName!(m::TokenCodecEncoder, src::Real) = referencedName!(m, Tuple(src))
@inline referencedName!(m::TokenCodecEncoder, ::Nothing) = referencedName_buffer!(m, 0)

function show(io::IO, m::TokenCodec{T}) where {T}
    println(io, "TokenCodec view over a type $T")
    println(io, "SbeBlockLength: ", sbe_block_length(m))
    println(io, "SbeTemplateId:  ", sbe_template_id(m))
    println(io, "SbeSchemaId:    ", sbe_schema_id(m))
    println(io, "SbeSchemaVersion: ", sbe_schema_version(m))

    writer = TokenCodecDecoder(sbe_buffer(m), sbe_offset(m), SBE.PositionPointer(),
        sbe_block_length(m), sbe_schema_version(m))
    print(io, "tokenOffset: ")
    print(io, tokenOffset(writer))

    println(io)
    print(io, "tokenSize: ")
    print(io, tokenSize(writer))

    println(io)
    print(io, "fieldId: ")
    print(io, fieldId(writer))

    println(io)
    print(io, "tokenVersion: ")
    print(io, tokenVersion(writer))

    println(io)
    print(io, "componentTokenCount: ")
    print(io, componentTokenCount(writer))

    println(io)
    print(io, "signal: ")
    print(io, signal(writer))

    println(io)
    print(io, "primitiveType: ")
    print(io, primitiveType(writer))

    println(io)
    print(io, "byteOrder: ")
    print(io, byteOrder(writer))

    println(io)
    print(io, "presence: ")
    print(io, presence(writer))

    println(io)
    print(io, "deprecated: ")
    print(io, deprecated(writer))

    println(io)
    print(io, "name: ")
    print(io, name(writer, StringView))

    println(io)
    print(io, "constValue: ")
    print(io, constValue(writer, StringView))

    println(io)
    print(io, "minValue: ")
    print(io, minValue(writer, StringView))

    println(io)
    print(io, "maxValue: ")
    print(io, maxValue(writer, StringView))

    println(io)
    print(io, "nullValue: ")
    print(io, nullValue(writer, StringView))

    println(io)
    print(io, "characterEncoding: ")
    print(io, characterEncoding(writer, StringView))

    println(io)
    print(io, "epoch: ")
    print(io, epoch(writer, StringView))

    println(io)
    print(io, "timeUnit: ")
    print(io, timeUnit(writer, StringView))

    println(io)
    print(io, "semanticType: ")
    print(io, semanticType(writer, StringView))

    println(io)
    print(io, "description: ")
    print(io, description(writer, StringView))

    println(io)
    print(io, "referencedName: ")
    print(io, referencedName(writer, StringView))

    nothing
end

@inline function sbe_skip!(m::TokenCodecDecoder)
    sbe_rewind!(m)
    skip_name!(m)
    skip_constValue!(m)
    skip_minValue!(m)
    skip_maxValue!(m)
    skip_nullValue!(m)
    skip_characterEncoding!(m)
    skip_epoch!(m)
    skip_timeUnit!(m)
    skip_semanticType!(m)
    skip_description!(m)
    skip_referencedName!(m)
    return
end
