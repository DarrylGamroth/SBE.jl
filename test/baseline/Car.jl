# Generated SBE (Simple Binary Encoding) message codec
# Code generated by SBE. DO NOT EDIT.

export Car, CarDecoder, CarEncoder
abstract type Car{T} end

struct CarDecoder{T<:AbstractArray{UInt8}} <: Car{T}
    buffer::T
    offset::Int64
    position_ptr::Base.RefValue{Int64}
    acting_block_length::UInt16
    acting_version::UInt16
    function CarDecoder(buffer::T, offset::Integer, position_ptr::Ref{Int64},
        acting_block_length::Integer, acting_version::Integer) where {T}
        position_ptr[] = offset + acting_block_length
        new{T}(buffer, offset, position_ptr, acting_block_length, acting_version)
    end
end

struct CarEncoder{T<:AbstractArray{UInt8},HasSbeHeader} <: Car{T}
    buffer::T
    offset::Int64
    position_ptr::Base.RefValue{Int64}
    function CarEncoder(buffer::T, offset::Integer,
        position_ptr::Ref{Int64}, hasSbeHeader::Bool=false) where {T}
        position_ptr[] = offset + 45
        new{T,hasSbeHeader}(buffer, offset, position_ptr)
    end
end

@inline function CarDecoder(buffer::AbstractArray, offset::Integer=0;
    position_ptr::Base.RefValue{Int64}=Ref(0),
    header::MessageHeader=MessageHeader(buffer, offset))
    if templateId(header) != UInt16(0x1) || schemaId(header) != UInt16(0x1)
        throw(DomainError("Template id or schema id mismatch"))
    end
    CarDecoder(buffer, offset + sbe_encoded_length(header), position_ptr,
        blockLength(header), version(header))
end
@inline function CarEncoder(buffer::AbstractArray, offset::Integer=0;
    position_ptr::Base.RefValue{Int64}=Ref(0),
    header::MessageHeader=MessageHeader(buffer, offset))
    blockLength!(header, UInt16(0x2d))
    templateId!(header, UInt16(0x1))
    schemaId!(header, UInt16(0x1))
    version!(header, UInt16(0x0))
    CarEncoder(buffer, offset + sbe_encoded_length(header), position_ptr, true)
end
sbe_buffer(m::Car) = m.buffer
sbe_offset(m::Car) = m.offset
sbe_position_ptr(m::Car) = m.position_ptr
sbe_position(m::Car) = m.position_ptr[]
sbe_position!(m::Car, position) = m.position_ptr[] = position
sbe_block_length(::Car) = UInt16(0x2d)
sbe_block_length(::Type{<:Car}) = UInt16(0x2d)
sbe_template_id(::Car) = UInt16(0x1)
sbe_template_id(::Type{<:Car})  = UInt16(0x1)
sbe_schema_id(::Car) = UInt16(0x1)
sbe_schema_id(::Type{<:Car})  = UInt16(0x1)
sbe_schema_version(::Car) = UInt16(0x0)
sbe_schema_version(::Type{<:Car})  = UInt16(0x0)
sbe_semantic_type(::Car) = ""
sbe_semantic_version(::Car) = "5.2"
sbe_acting_block_length(m::CarDecoder) = m.acting_block_length
sbe_acting_block_length(::CarEncoder) = UInt16(0x2d)
sbe_acting_version(m::CarDecoder) = m.acting_version
sbe_acting_version(::CarEncoder) = UInt16(0x0)
sbe_rewind!(m::Car) = sbe_position!(m, m.offset + sbe_acting_block_length(m))
sbe_encoded_length(m::Car) = sbe_position(m) - m.offset
@inline function sbe_decoded_length(m::Car)
    skipper = CarDecoder(sbe_buffer(m), sbe_offset(m), Ref(0),
        sbe_acting_block_length(m), sbe_acting_version(m))
    sbe_skip!(skipper)
    sbe_encoded_length(skipper)
end

Base.sizeof(m::Car) = sbe_decoded_length(m)
function Base.convert(::Type{AbstractArray{UInt8}}, m::CarEncoder{<:AbstractArray{UInt8},true})
    return view(m.buffer, m.offset+1-sbe_encoded_length(MessageHeader):m.offset+sbe_encoded_length(m))
end
function Base.convert(::Type{AbstractArray{UInt8}}, m::CarEncoder{<:AbstractArray{UInt8},false})
    return view(m.buffer, m.offset+1:m.offset+sbe_encoded_length(m))
end

function serialNumber_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
serialNumber_id(::Car) = UInt16(0x1)
serialNumber_id(::Type{<:Car}) = UInt16(0x1)
serialNumber_since_version(::Car) = UInt16(0x0)
serialNumber_since_version(::Type{<:Car}) = UInt16(0x0)
serialNumber_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
serialNumber_encoding_offset(::Car) = 0
serialNumber_encoding_offset(::Type{<:Car}) = 0
serialNumber_null_value(::Car) = UInt64(0xffffffffffffffff)
serialNumber_null_value(::Type{<:Car}) = UInt64(0xffffffffffffffff)
serialNumber_min_value(::Car) = UInt64(0x0)
serialNumber_min_value(::Type{<:Car}) = UInt64(0x0)
serialNumber_max_value(::Car) = UInt64(0xfffffffffffffffe)
serialNumber_max_value(::Type{<:Car}) = UInt64(0xfffffffffffffffe)
serialNumber_encoding_length(::Car) = 8
serialNumber_encoding_length(::Type{<:Car}) = 8

@inline function serialNumber(m::CarDecoder)
    return decode_le(UInt64, m.buffer, m.offset + 0)
end
@inline serialNumber!(m::CarEncoder, value) = encode_le(UInt64, m.buffer, m.offset + 0, value)

function modelYear_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
modelYear_id(::Car) = UInt16(0x2)
modelYear_id(::Type{<:Car}) = UInt16(0x2)
modelYear_since_version(::Car) = UInt16(0x0)
modelYear_since_version(::Type{<:Car}) = UInt16(0x0)
modelYear_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
modelYear_encoding_offset(::Car) = 8
modelYear_encoding_offset(::Type{<:Car}) = 8
modelYear_null_value(::Car) = UInt16(0xffff)
modelYear_null_value(::Type{<:Car}) = UInt16(0xffff)
modelYear_min_value(::Car) = UInt16(0x0)
modelYear_min_value(::Type{<:Car}) = UInt16(0x0)
modelYear_max_value(::Car) = UInt16(0xfffe)
modelYear_max_value(::Type{<:Car}) = UInt16(0xfffe)
modelYear_encoding_length(::Car) = 2
modelYear_encoding_length(::Type{<:Car}) = 2

@inline function modelYear(m::CarDecoder)
    return decode_le(UInt16, m.buffer, m.offset + 8)
end
@inline modelYear!(m::CarEncoder, value) = encode_le(UInt16, m.buffer, m.offset + 8, value)

function available_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
available_id(::Car) = UInt16(0x3)
available_id(::Type{<:Car}) = UInt16(0x3)
available_since_version(::Car) = UInt16(0x0)
available_since_version(::Type{<:Car}) = UInt16(0x0)
available_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
available_encoding_offset(::Car) = 10
available_encoding_offset(::Type{<:Car}) = 10
available_encoding_length(::Car) = 1
available_encoding_length(::Type{<:Car}) = 1
@inline function available(m::CarDecoder, ::Type{Integer})
    return decode_le(UInt8, m.buffer, m.offset + 10)
end
@inline function available(m::CarDecoder)
    return BooleanType.SbeEnum(decode_le(UInt8, m.buffer, m.offset + 10))
end
@inline available!(m::CarEncoder, value::BooleanType.SbeEnum) = encode_le(UInt8, m.buffer, m.offset + 10, UInt8(value))

function code_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
code_id(::Car) = UInt16(0x4)
code_id(::Type{<:Car}) = UInt16(0x4)
code_since_version(::Car) = UInt16(0x0)
code_since_version(::Type{<:Car}) = UInt16(0x0)
code_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
code_encoding_offset(::Car) = 11
code_encoding_offset(::Type{<:Car}) = 11
code_encoding_length(::Car) = 1
code_encoding_length(::Type{<:Car}) = 1
@inline function code(m::CarDecoder, ::Type{Integer})
    return decode_le(UInt8, m.buffer, m.offset + 11)
end
@inline function code(m::CarDecoder)
    return Model.SbeEnum(decode_le(UInt8, m.buffer, m.offset + 11))
end
@inline code!(m::CarEncoder, value::Model.SbeEnum) = encode_le(UInt8, m.buffer, m.offset + 11, UInt8(value))

function someNumbers_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
someNumbers_id(::Car) = UInt16(0x5)
someNumbers_id(::Type{<:Car}) = UInt16(0x5)
someNumbers_since_version(::Car) = UInt16(0x0)
someNumbers_since_version(::Type{<:Car}) = UInt16(0x0)
someNumbers_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
someNumbers_encoding_offset(::Car) = 12
someNumbers_encoding_offset(::Type{<:Car}) = 12
someNumbers_null_value(::Car) = UInt32(0xffffffff)
someNumbers_null_value(::Type{<:Car}) = UInt32(0xffffffff)
someNumbers_min_value(::Car) = UInt32(0x0)
someNumbers_min_value(::Type{<:Car}) = UInt32(0x0)
someNumbers_max_value(::Car) = UInt32(0xfffffffe)
someNumbers_max_value(::Type{<:Car}) = UInt32(0xfffffffe)
someNumbers_encoding_length(::Car) = 16
someNumbers_encoding_length(::Type{<:Car}) = 16
someNumbers_length(::Car) = 4
someNumbers_length(::Type{<:Car}) = 4
someNumbers_eltype(::Car) = UInt32
someNumbers_eltype(::Type{<:Car}) = UInt32

@inline function someNumbers(m::CarDecoder)
    return mappedarray(ltoh, reinterpret(UInt32, view(m.buffer, m.offset+12+1:m.offset+12+sizeof(UInt32)*4)))
end

@inline function someNumbers(m::CarDecoder, ::Type{<:SVector})
    return mappedarray(ltoh, reinterpret(SVector{4,UInt32}, view(m.buffer, m.offset+12+1:m.offset+12+sizeof(UInt32)*4))[])
end

@inline function someNumbers!(m::CarEncoder)
    return mappedarray(ltoh, htol, reinterpret(UInt32, view(m.buffer, m.offset+12+1:m.offset+12+sizeof(UInt32)*4)))
end

@inline function someNumbers!(m::CarEncoder, value)
    copyto!(someNumbers!(m), value)
end

function vehicleCode_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
vehicleCode_id(::Car) = UInt16(0x6)
vehicleCode_id(::Type{<:Car}) = UInt16(0x6)
vehicleCode_since_version(::Car) = UInt16(0x0)
vehicleCode_since_version(::Type{<:Car}) = UInt16(0x0)
vehicleCode_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
vehicleCode_encoding_offset(::Car) = 28
vehicleCode_encoding_offset(::Type{<:Car}) = 28
vehicleCode_null_value(::Car) = UInt8(0x0)
vehicleCode_null_value(::Type{<:Car}) = UInt8(0x0)
vehicleCode_min_value(::Car) = UInt8(0x20)
vehicleCode_min_value(::Type{<:Car}) = UInt8(0x20)
vehicleCode_max_value(::Car) = UInt8(0x7e)
vehicleCode_max_value(::Type{<:Car}) = UInt8(0x7e)
vehicleCode_encoding_length(::Car) = 6
vehicleCode_encoding_length(::Type{<:Car}) = 6
vehicleCode_length(::Car) = 6
vehicleCode_length(::Type{<:Car}) = 6
vehicleCode_eltype(::Car) = UInt8
vehicleCode_eltype(::Type{<:Car}) = UInt8

@inline function vehicleCode(m::CarDecoder)
    return mappedarray(ltoh, reinterpret(UInt8, view(m.buffer, m.offset+28+1:m.offset+28+sizeof(UInt8)*6)))
end

@inline function vehicleCode(m::CarDecoder, ::Type{<:SVector})
    return mappedarray(ltoh, reinterpret(SVector{6,UInt8}, view(m.buffer, m.offset+28+1:m.offset+28+sizeof(UInt8)*6))[])
end

@inline function vehicleCode(m::CarDecoder, ::Type{<:AbstractString})
    value = view(m.buffer, m.offset+1+28:m.offset+28+sizeof(UInt8)*6)
    return StringView(rstrip_nul(value))
end

@inline function vehicleCode(m::CarDecoder, ::Type{<:Symbol})
    Symbol(vehicleCode(m, AbstractString))
end

@inline function vehicleCode!(m::CarEncoder)
    return mappedarray(ltoh, htol, reinterpret(UInt8, view(m.buffer, m.offset+28+1:m.offset+28+sizeof(UInt8)*6)))
end

@inline function vehicleCode!(m::CarEncoder, value)
    copyto!(vehicleCode!(m), value)
end

@inline function vehicleCode!(m::CarEncoder, value::AbstractString)
    dest = vehicleCode!(m)
    fill!(dest, 0)
    copyto!(dest, value)
end

@inline function vehicleCode!(m::CarEncoder, value::Symbol)
    vehicleCode!(m, to_string(value))
end

function extras_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
extras_id(::Car) = UInt16(0x7)
extras_id(::Type{<:Car}) = UInt16(0x7)
extras_since_version(::Car) = UInt16(0x0)
extras_since_version(::Type{<:Car}) = UInt16(0x0)
extras_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
extras_encoding_offset(::Car) = 34
extras_encoding_offset(::Type{<:Car}) = 34
extras(m::Car) = OptionalExtras(m.buffer, m.offset + 34)
extras_encoding_length(::Car) = 1

function discountedModel_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("constant")
    return Symbol("")
end
discountedModel_id(::Car) = UInt16(0x8)
discountedModel_id(::Type{<:Car}) = UInt16(0x8)
discountedModel_since_version(::Car) = UInt16(0x0)
discountedModel_since_version(::Type{<:Car}) = UInt16(0x0)
discountedModel_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
discountedModel_encoding_offset(::Car) = 35
discountedModel_encoding_offset(::Type{<:Car}) = 35
discountedModel_encoding_length(::Car) = 0
discountedModel_encoding_length(::Type{<:Car}) = 0
discountedModel(::CarDecoder, ::Type{Integer}) = UInt8(Model.C)
@inline function discountedModel(m::CarDecoder)
    return Model.C
end

function engine_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
engine_id(::Car) = UInt16(0x9)
engine_id(::Type{<:Car}) = UInt16(0x9)
engine_since_version(::Car) = UInt16(0x0)
engine_since_version(::Type{<:Car}) = UInt16(0x0)
engine_in_acting_version(m::Car) = sbe_acting_version(m) >= UInt16(0x0)
engine_encoding_offset(::Car) = 35
engine_encoding_offset(::Type{<:Car}) = 35
engine(m::Car) = Engine(m.buffer, m.offset + 35, sbe_acting_version(m))

export CarFuelFigures, CarFuelFiguresDecoder, CarFuelFiguresEncoder
abstract type CarFuelFigures{T} end

mutable struct CarFuelFiguresDecoder{T<:AbstractArray{UInt8}} <: CarFuelFigures{T}
    const buffer::T
    offset::Int64
    const position_ptr::Base.RefValue{Int64}
    const block_length::UInt16
    const acting_version::UInt16
    const count::UInt16
    index::UInt16
    function CarFuelFiguresDecoder(buffer::T, offset::Integer, position_ptr::Ref{Int64},
        block_length::Integer, acting_version::Integer,
        count::Integer, index::Integer) where {T}
        new{T}(buffer, offset, position_ptr, block_length, acting_version, count, index)
    end
end

mutable struct CarFuelFiguresEncoder{T<:AbstractArray{UInt8}} <: CarFuelFigures{T}
    const buffer::T
    offset::Int64
    const position_ptr::Base.RefValue{Int64}
    const initial_position::Int64
    const count::UInt16
    index::UInt16
    function CarFuelFiguresEncoder(buffer::T, offset::Integer, position_ptr::Ref{Int64},
        initial_position::Int64, count::Integer, index::Integer) where {T}
        new{T}(buffer, offset, position_ptr, initial_position, count, index)
    end
end

@inline function CarFuelFiguresDecoder(buffer, position_ptr, acting_version)
    dimensions = GroupSizeEncoding(buffer, position_ptr[])
    position_ptr[] += 4
    return CarFuelFiguresDecoder(buffer, 0, position_ptr, blockLength(dimensions),
        acting_version, numInGroup(dimensions), 0)
end

@inline function CarFuelFiguresEncoder(buffer, count, position_ptr)
    if count > 65534
        error("count outside of allowed range")
    end
    dimensions = GroupSizeEncoding(buffer, position_ptr[])
    blockLength!(dimensions, UInt16(0x6))
    numInGroup!(dimensions, count)
    initial_position = position_ptr[]
    position_ptr[] += 4
    return CarFuelFiguresEncoder(buffer, 0, position_ptr, initial_position, count, 0)
end

sbe_header_size(::CarFuelFigures) = 4
sbe_block_length(::CarFuelFigures) = UInt16(0x6)
sbe_acting_block_length(g::CarFuelFiguresDecoder) = g.block_length
sbe_acting_block_length(g::CarFuelFiguresEncoder) = UInt16(0x6)
sbe_acting_version(g::CarFuelFiguresDecoder) = g.acting_version
sbe_acting_version(::CarFuelFiguresEncoder) = UInt16(0x0)
sbe_position(g::CarFuelFigures) = g.position_ptr[]
@inline sbe_position!(g::CarFuelFigures, position) = g.position_ptr[] = position
sbe_position_ptr(g::CarFuelFigures) = g.position_ptr
@inline function next!(g::CarFuelFigures)
    if g.index >= g.count
        error("index >= count")
    end
    g.offset = sbe_position(g)
    sbe_position!(g, g.offset + sbe_acting_block_length(g))
    g.index += 1
    return g
end
function Base.iterate(g::CarFuelFigures, state=nothing)
    if g.index < g.count
        g.offset = sbe_position(g)
        sbe_position!(g, g.offset + sbe_acting_block_length(g))
        g.index += 1
        return g, state
    else
        return nothing
    end
end
Base.eltype(::Type{<:CarFuelFigures}) = CarFuelFigures
Base.isdone(g::CarFuelFigures, state=nothing) = g.index >= g.count
Base.length(g::CarFuelFigures) = g.count

function reset_count_to_index!(g::CarFuelFiguresEncoder)
    g.count = g.index
    dimensions = GroupSizeEncoding(g.buffer, g.initial_position)
    numInGroup!(dimensions, g.count)
    return g.count
end

function speed_meta_attribute(::CarFuelFigures, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
speed_id(::CarFuelFigures) = UInt16(0xb)
speed_id(::Type{<:CarFuelFigures}) = UInt16(0xb)
speed_since_version(::CarFuelFigures) = UInt16(0x0)
speed_since_version(::Type{<:CarFuelFigures}) = UInt16(0x0)
speed_in_acting_version(m::CarFuelFigures) = sbe_acting_version(m) >= UInt16(0x0)
speed_encoding_offset(::CarFuelFigures) = 0
speed_encoding_offset(::Type{<:CarFuelFigures}) = 0
speed_null_value(::CarFuelFigures) = UInt16(0xffff)
speed_null_value(::Type{<:CarFuelFigures}) = UInt16(0xffff)
speed_min_value(::CarFuelFigures) = UInt16(0x0)
speed_min_value(::Type{<:CarFuelFigures}) = UInt16(0x0)
speed_max_value(::CarFuelFigures) = UInt16(0xfffe)
speed_max_value(::Type{<:CarFuelFigures}) = UInt16(0xfffe)
speed_encoding_length(::CarFuelFigures) = 2
speed_encoding_length(::Type{<:CarFuelFigures}) = 2

@inline function speed(m::CarFuelFiguresDecoder)
    return decode_le(UInt16, m.buffer, m.offset + 0)
end
@inline speed!(m::CarFuelFiguresEncoder, value) = encode_le(UInt16, m.buffer, m.offset + 0, value)

function mpg_meta_attribute(::CarFuelFigures, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
mpg_id(::CarFuelFigures) = UInt16(0xc)
mpg_id(::Type{<:CarFuelFigures}) = UInt16(0xc)
mpg_since_version(::CarFuelFigures) = UInt16(0x0)
mpg_since_version(::Type{<:CarFuelFigures}) = UInt16(0x0)
mpg_in_acting_version(m::CarFuelFigures) = sbe_acting_version(m) >= UInt16(0x0)
mpg_encoding_offset(::CarFuelFigures) = 2
mpg_encoding_offset(::Type{<:CarFuelFigures}) = 2
mpg_null_value(::CarFuelFigures) = NaN32
mpg_null_value(::Type{<:CarFuelFigures}) = NaN32
mpg_min_value(::CarFuelFigures) = Float32(-3.4028234663852886E38)
mpg_min_value(::Type{<:CarFuelFigures}) = Float32(-3.4028234663852886E38)
mpg_max_value(::CarFuelFigures) = Float32(3.4028234663852886E38)
mpg_max_value(::Type{<:CarFuelFigures}) = Float32(3.4028234663852886E38)
mpg_encoding_length(::CarFuelFigures) = 4
mpg_encoding_length(::Type{<:CarFuelFigures}) = 4

@inline function mpg(m::CarFuelFiguresDecoder)
    return decode_le(Float32, m.buffer, m.offset + 2)
end
@inline mpg!(m::CarFuelFiguresEncoder, value) = encode_le(Float32, m.buffer, m.offset + 2, value)

function usageDescription_meta_attribute(::CarFuelFigures, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

usageDescription_character_encoding(::CarFuelFigures) = "ASCII"
usageDescription_character_encoding(::Type{<:CarFuelFigures}) = "ASCII"
usageDescription_in_acting_version(m::CarFuelFigures) = sbe_acting_version(m) >= 0
usageDescription_id(::CarFuelFigures) = 200
usageDescription_id(::Type{<:CarFuelFigures}) = 200
usageDescription_header_length(::CarFuelFigures) = 4
usageDescription_header_length(::Type{<:CarFuelFigures}) = 4

@inline function usageDescription_length(m::CarFuelFigures)
    return decode_le(UInt32, m.buffer, sbe_position(m))
end

@inline function usageDescription_length!(m::CarFuelFiguresEncoder, n)
    @boundscheck n > 1073741824 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 4 + n)
    return encode_le(UInt32, m.buffer, sbe_position(m), n)
end

@inline function skip_usageDescription!(m::CarFuelFiguresDecoder)
    len = usageDescription_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return len
end

@inline function usageDescription(m::CarFuelFiguresDecoder)
    len = usageDescription_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline usageDescription(m::CarFuelFiguresDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, usageDescription(m))
@inline usageDescription(m::CarFuelFiguresDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, usageDescription(m)); ntuple(i -> x[i], Val(N)))
@inline usageDescription(m::CarFuelFiguresDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(usageDescription(m)))
@inline usageDescription(m::CarFuelFiguresDecoder, ::Type{T}) where {T<:Symbol} = Symbol(usageDescription(m, StringView))
@inline usageDescription(m::CarFuelFiguresDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, usageDescription(m))[]
@inline usageDescription(m::CarFuelFiguresDecoder, ::Type{T}) where {T<:Nothing} = (skip_usageDescription!(m); nothing)

@inline function usageDescription_buffer!(m::CarFuelFiguresEncoder, len)
    usageDescription_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function usageDescription!(m::CarFuelFiguresEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    usageDescription_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function usageDescription!(m::CarFuelFiguresEncoder, src::NTuple)
    len = sizeof(src)
    usageDescription_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function usageDescription!(m::CarFuelFiguresEncoder, src::AbstractString)
    len = sizeof(src)
    usageDescription_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline usageDescription!(m::CarFuelFiguresEncoder, src::Symbol) = usageDescription!(m, to_string(src))
@inline usageDescription!(m::CarFuelFiguresEncoder, src::StaticString) = usageDescription!(m, Tuple(src))
@inline usageDescription!(m::CarFuelFiguresEncoder, src::Real) = usageDescription!(m, Tuple(src))
@inline usageDescription!(m::CarFuelFiguresEncoder, ::Nothing) = usageDescription_buffer!(m, 0)

function show(io::IO, writer::CarFuelFigures{T}) where {T}
    println(io, "CarFuelFigures view over a type $T")
    print(io, "speed: ")
    print(io, speed(writer))

    println(io)
    print(io, "mpg: ")
    print(io, mpg(writer))

    println(io)
    print(io, "usageDescription: ")
    print(io, usageDescription(writer, StringView))

end

@inline function sbe_skip!(m::CarFuelFiguresDecoder)
    
    skip_usageDescription!(m)
    return
end

@inline function fuelFigures(m::Car)
    return CarFuelFiguresDecoder(m.buffer, sbe_position_ptr(m), sbe_acting_version(m))
end

@inline function fuelFigures!(m::Car, count)
    return CarFuelFiguresEncoder(m.buffer, count, sbe_position_ptr(m))
end
fuelFigures_group_count!(m::CarEncoder, count) = fuelFigures!(m, count)
fuelFigures_id(::Car) = 10
fuelFigures_since_version(::Car) = 0
fuelFigures_in_acting_version(m::Car) = sbe_acting_version(m) >= 0

export CarPerformanceFigures, CarPerformanceFiguresDecoder, CarPerformanceFiguresEncoder
abstract type CarPerformanceFigures{T} end

mutable struct CarPerformanceFiguresDecoder{T<:AbstractArray{UInt8}} <: CarPerformanceFigures{T}
    const buffer::T
    offset::Int64
    const position_ptr::Base.RefValue{Int64}
    const block_length::UInt16
    const acting_version::UInt16
    const count::UInt16
    index::UInt16
    function CarPerformanceFiguresDecoder(buffer::T, offset::Integer, position_ptr::Ref{Int64},
        block_length::Integer, acting_version::Integer,
        count::Integer, index::Integer) where {T}
        new{T}(buffer, offset, position_ptr, block_length, acting_version, count, index)
    end
end

mutable struct CarPerformanceFiguresEncoder{T<:AbstractArray{UInt8}} <: CarPerformanceFigures{T}
    const buffer::T
    offset::Int64
    const position_ptr::Base.RefValue{Int64}
    const initial_position::Int64
    const count::UInt16
    index::UInt16
    function CarPerformanceFiguresEncoder(buffer::T, offset::Integer, position_ptr::Ref{Int64},
        initial_position::Int64, count::Integer, index::Integer) where {T}
        new{T}(buffer, offset, position_ptr, initial_position, count, index)
    end
end

@inline function CarPerformanceFiguresDecoder(buffer, position_ptr, acting_version)
    dimensions = GroupSizeEncoding(buffer, position_ptr[])
    position_ptr[] += 4
    return CarPerformanceFiguresDecoder(buffer, 0, position_ptr, blockLength(dimensions),
        acting_version, numInGroup(dimensions), 0)
end

@inline function CarPerformanceFiguresEncoder(buffer, count, position_ptr)
    if count > 65534
        error("count outside of allowed range")
    end
    dimensions = GroupSizeEncoding(buffer, position_ptr[])
    blockLength!(dimensions, UInt16(0x1))
    numInGroup!(dimensions, count)
    initial_position = position_ptr[]
    position_ptr[] += 4
    return CarPerformanceFiguresEncoder(buffer, 0, position_ptr, initial_position, count, 0)
end

sbe_header_size(::CarPerformanceFigures) = 4
sbe_block_length(::CarPerformanceFigures) = UInt16(0x1)
sbe_acting_block_length(g::CarPerformanceFiguresDecoder) = g.block_length
sbe_acting_block_length(g::CarPerformanceFiguresEncoder) = UInt16(0x1)
sbe_acting_version(g::CarPerformanceFiguresDecoder) = g.acting_version
sbe_acting_version(::CarPerformanceFiguresEncoder) = UInt16(0x0)
sbe_position(g::CarPerformanceFigures) = g.position_ptr[]
@inline sbe_position!(g::CarPerformanceFigures, position) = g.position_ptr[] = position
sbe_position_ptr(g::CarPerformanceFigures) = g.position_ptr
@inline function next!(g::CarPerformanceFigures)
    if g.index >= g.count
        error("index >= count")
    end
    g.offset = sbe_position(g)
    sbe_position!(g, g.offset + sbe_acting_block_length(g))
    g.index += 1
    return g
end
function Base.iterate(g::CarPerformanceFigures, state=nothing)
    if g.index < g.count
        g.offset = sbe_position(g)
        sbe_position!(g, g.offset + sbe_acting_block_length(g))
        g.index += 1
        return g, state
    else
        return nothing
    end
end
Base.eltype(::Type{<:CarPerformanceFigures}) = CarPerformanceFigures
Base.isdone(g::CarPerformanceFigures, state=nothing) = g.index >= g.count
Base.length(g::CarPerformanceFigures) = g.count

function reset_count_to_index!(g::CarPerformanceFiguresEncoder)
    g.count = g.index
    dimensions = GroupSizeEncoding(g.buffer, g.initial_position)
    numInGroup!(dimensions, g.count)
    return g.count
end

function octaneRating_meta_attribute(::CarPerformanceFigures, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
octaneRating_id(::CarPerformanceFigures) = UInt16(0xe)
octaneRating_id(::Type{<:CarPerformanceFigures}) = UInt16(0xe)
octaneRating_since_version(::CarPerformanceFigures) = UInt16(0x0)
octaneRating_since_version(::Type{<:CarPerformanceFigures}) = UInt16(0x0)
octaneRating_in_acting_version(m::CarPerformanceFigures) = sbe_acting_version(m) >= UInt16(0x0)
octaneRating_encoding_offset(::CarPerformanceFigures) = 0
octaneRating_encoding_offset(::Type{<:CarPerformanceFigures}) = 0
octaneRating_null_value(::CarPerformanceFigures) = UInt8(0xff)
octaneRating_null_value(::Type{<:CarPerformanceFigures}) = UInt8(0xff)
octaneRating_min_value(::CarPerformanceFigures) = UInt8(0x5a)
octaneRating_min_value(::Type{<:CarPerformanceFigures}) = UInt8(0x5a)
octaneRating_max_value(::CarPerformanceFigures) = UInt8(0x6e)
octaneRating_max_value(::Type{<:CarPerformanceFigures}) = UInt8(0x6e)
octaneRating_encoding_length(::CarPerformanceFigures) = 1
octaneRating_encoding_length(::Type{<:CarPerformanceFigures}) = 1

@inline function octaneRating(m::CarPerformanceFiguresDecoder)
    return decode_le(UInt8, m.buffer, m.offset + 0)
end
@inline octaneRating!(m::CarPerformanceFiguresEncoder, value) = encode_le(UInt8, m.buffer, m.offset + 0, value)

export CarPerformanceFiguresAcceleration, CarPerformanceFiguresAccelerationDecoder, CarPerformanceFiguresAccelerationEncoder
abstract type CarPerformanceFiguresAcceleration{T} end

mutable struct CarPerformanceFiguresAccelerationDecoder{T<:AbstractArray{UInt8}} <: CarPerformanceFiguresAcceleration{T}
    const buffer::T
    offset::Int64
    const position_ptr::Base.RefValue{Int64}
    const block_length::UInt16
    const acting_version::UInt16
    const count::UInt16
    index::UInt16
    function CarPerformanceFiguresAccelerationDecoder(buffer::T, offset::Integer, position_ptr::Ref{Int64},
        block_length::Integer, acting_version::Integer,
        count::Integer, index::Integer) where {T}
        new{T}(buffer, offset, position_ptr, block_length, acting_version, count, index)
    end
end

mutable struct CarPerformanceFiguresAccelerationEncoder{T<:AbstractArray{UInt8}} <: CarPerformanceFiguresAcceleration{T}
    const buffer::T
    offset::Int64
    const position_ptr::Base.RefValue{Int64}
    const initial_position::Int64
    const count::UInt16
    index::UInt16
    function CarPerformanceFiguresAccelerationEncoder(buffer::T, offset::Integer, position_ptr::Ref{Int64},
        initial_position::Int64, count::Integer, index::Integer) where {T}
        new{T}(buffer, offset, position_ptr, initial_position, count, index)
    end
end

@inline function CarPerformanceFiguresAccelerationDecoder(buffer, position_ptr, acting_version)
    dimensions = GroupSizeEncoding(buffer, position_ptr[])
    position_ptr[] += 4
    return CarPerformanceFiguresAccelerationDecoder(buffer, 0, position_ptr, blockLength(dimensions),
        acting_version, numInGroup(dimensions), 0)
end

@inline function CarPerformanceFiguresAccelerationEncoder(buffer, count, position_ptr)
    if count > 65534
        error("count outside of allowed range")
    end
    dimensions = GroupSizeEncoding(buffer, position_ptr[])
    blockLength!(dimensions, UInt16(0x6))
    numInGroup!(dimensions, count)
    initial_position = position_ptr[]
    position_ptr[] += 4
    return CarPerformanceFiguresAccelerationEncoder(buffer, 0, position_ptr, initial_position, count, 0)
end

sbe_header_size(::CarPerformanceFiguresAcceleration) = 4
sbe_block_length(::CarPerformanceFiguresAcceleration) = UInt16(0x6)
sbe_acting_block_length(g::CarPerformanceFiguresAccelerationDecoder) = g.block_length
sbe_acting_block_length(g::CarPerformanceFiguresAccelerationEncoder) = UInt16(0x6)
sbe_acting_version(g::CarPerformanceFiguresAccelerationDecoder) = g.acting_version
sbe_acting_version(::CarPerformanceFiguresAccelerationEncoder) = UInt16(0x0)
sbe_position(g::CarPerformanceFiguresAcceleration) = g.position_ptr[]
@inline sbe_position!(g::CarPerformanceFiguresAcceleration, position) = g.position_ptr[] = position
sbe_position_ptr(g::CarPerformanceFiguresAcceleration) = g.position_ptr
@inline function next!(g::CarPerformanceFiguresAcceleration)
    if g.index >= g.count
        error("index >= count")
    end
    g.offset = sbe_position(g)
    sbe_position!(g, g.offset + sbe_acting_block_length(g))
    g.index += 1
    return g
end
function Base.iterate(g::CarPerformanceFiguresAcceleration, state=nothing)
    if g.index < g.count
        g.offset = sbe_position(g)
        sbe_position!(g, g.offset + sbe_acting_block_length(g))
        g.index += 1
        return g, state
    else
        return nothing
    end
end
Base.eltype(::Type{<:CarPerformanceFiguresAcceleration}) = CarPerformanceFiguresAcceleration
Base.isdone(g::CarPerformanceFiguresAcceleration, state=nothing) = g.index >= g.count
Base.length(g::CarPerformanceFiguresAcceleration) = g.count

function reset_count_to_index!(g::CarPerformanceFiguresAccelerationEncoder)
    g.count = g.index
    dimensions = GroupSizeEncoding(g.buffer, g.initial_position)
    numInGroup!(dimensions, g.count)
    return g.count
end

function mph_meta_attribute(::CarPerformanceFiguresAcceleration, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
mph_id(::CarPerformanceFiguresAcceleration) = UInt16(0x10)
mph_id(::Type{<:CarPerformanceFiguresAcceleration}) = UInt16(0x10)
mph_since_version(::CarPerformanceFiguresAcceleration) = UInt16(0x0)
mph_since_version(::Type{<:CarPerformanceFiguresAcceleration}) = UInt16(0x0)
mph_in_acting_version(m::CarPerformanceFiguresAcceleration) = sbe_acting_version(m) >= UInt16(0x0)
mph_encoding_offset(::CarPerformanceFiguresAcceleration) = 0
mph_encoding_offset(::Type{<:CarPerformanceFiguresAcceleration}) = 0
mph_null_value(::CarPerformanceFiguresAcceleration) = UInt16(0xffff)
mph_null_value(::Type{<:CarPerformanceFiguresAcceleration}) = UInt16(0xffff)
mph_min_value(::CarPerformanceFiguresAcceleration) = UInt16(0x0)
mph_min_value(::Type{<:CarPerformanceFiguresAcceleration}) = UInt16(0x0)
mph_max_value(::CarPerformanceFiguresAcceleration) = UInt16(0xfffe)
mph_max_value(::Type{<:CarPerformanceFiguresAcceleration}) = UInt16(0xfffe)
mph_encoding_length(::CarPerformanceFiguresAcceleration) = 2
mph_encoding_length(::Type{<:CarPerformanceFiguresAcceleration}) = 2

@inline function mph(m::CarPerformanceFiguresAccelerationDecoder)
    return decode_le(UInt16, m.buffer, m.offset + 0)
end
@inline mph!(m::CarPerformanceFiguresAccelerationEncoder, value) = encode_le(UInt16, m.buffer, m.offset + 0, value)

function seconds_meta_attribute(::CarPerformanceFiguresAcceleration, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
seconds_id(::CarPerformanceFiguresAcceleration) = UInt16(0x11)
seconds_id(::Type{<:CarPerformanceFiguresAcceleration}) = UInt16(0x11)
seconds_since_version(::CarPerformanceFiguresAcceleration) = UInt16(0x0)
seconds_since_version(::Type{<:CarPerformanceFiguresAcceleration}) = UInt16(0x0)
seconds_in_acting_version(m::CarPerformanceFiguresAcceleration) = sbe_acting_version(m) >= UInt16(0x0)
seconds_encoding_offset(::CarPerformanceFiguresAcceleration) = 2
seconds_encoding_offset(::Type{<:CarPerformanceFiguresAcceleration}) = 2
seconds_null_value(::CarPerformanceFiguresAcceleration) = NaN32
seconds_null_value(::Type{<:CarPerformanceFiguresAcceleration}) = NaN32
seconds_min_value(::CarPerformanceFiguresAcceleration) = Float32(-3.4028234663852886E38)
seconds_min_value(::Type{<:CarPerformanceFiguresAcceleration}) = Float32(-3.4028234663852886E38)
seconds_max_value(::CarPerformanceFiguresAcceleration) = Float32(3.4028234663852886E38)
seconds_max_value(::Type{<:CarPerformanceFiguresAcceleration}) = Float32(3.4028234663852886E38)
seconds_encoding_length(::CarPerformanceFiguresAcceleration) = 4
seconds_encoding_length(::Type{<:CarPerformanceFiguresAcceleration}) = 4

@inline function seconds(m::CarPerformanceFiguresAccelerationDecoder)
    return decode_le(Float32, m.buffer, m.offset + 2)
end
@inline seconds!(m::CarPerformanceFiguresAccelerationEncoder, value) = encode_le(Float32, m.buffer, m.offset + 2, value)

function show(io::IO, writer::CarPerformanceFiguresAcceleration{T}) where {T}
    println(io, "CarPerformanceFiguresAcceleration view over a type $T")
    print(io, "mph: ")
    print(io, mph(writer))

    println(io)
    print(io, "seconds: ")
    print(io, seconds(writer))

end

@inline function sbe_skip!(m::CarPerformanceFiguresAccelerationDecoder)
    
    return
end

@inline function acceleration(m::CarPerformanceFigures)
    return CarPerformanceFiguresAccelerationDecoder(m.buffer, sbe_position_ptr(m), sbe_acting_version(m))
end

@inline function acceleration!(m::CarPerformanceFigures, count)
    return CarPerformanceFiguresAccelerationEncoder(m.buffer, count, sbe_position_ptr(m))
end
acceleration_group_count!(m::CarPerformanceFiguresEncoder, count) = acceleration!(m, count)
acceleration_id(::CarPerformanceFigures) = 15
acceleration_since_version(::CarPerformanceFigures) = 0
acceleration_in_acting_version(m::CarPerformanceFigures) = sbe_acting_version(m) >= 0

function show(io::IO, writer::CarPerformanceFigures{T}) where {T}
    println(io, "CarPerformanceFigures view over a type $T")
    print(io, "octaneRating: ")
    print(io, octaneRating(writer))

    println(io)
    println(io, "Acceleration:")
    for group in acceleration(writer)
        show(io, group)
        println(io)
    end
end

@inline function sbe_skip!(m::CarPerformanceFiguresDecoder)
    
    for group in acceleration(m)
        sbe_skip!(group)
    end
    return
end

@inline function performanceFigures(m::Car)
    return CarPerformanceFiguresDecoder(m.buffer, sbe_position_ptr(m), sbe_acting_version(m))
end

@inline function performanceFigures!(m::Car, count)
    return CarPerformanceFiguresEncoder(m.buffer, count, sbe_position_ptr(m))
end
performanceFigures_group_count!(m::CarEncoder, count) = performanceFigures!(m, count)
performanceFigures_id(::Car) = 13
performanceFigures_since_version(::Car) = 0
performanceFigures_in_acting_version(m::Car) = sbe_acting_version(m) >= 0

function manufacturer_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

manufacturer_character_encoding(::Car) = "UTF-8"
manufacturer_character_encoding(::Type{<:Car}) = "UTF-8"
manufacturer_in_acting_version(m::Car) = sbe_acting_version(m) >= 0
manufacturer_id(::Car) = 18
manufacturer_id(::Type{<:Car}) = 18
manufacturer_header_length(::Car) = 4
manufacturer_header_length(::Type{<:Car}) = 4

@inline function manufacturer_length(m::Car)
    return decode_le(UInt32, m.buffer, sbe_position(m))
end

@inline function manufacturer_length!(m::CarEncoder, n)
    @boundscheck n > 1073741824 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 4 + n)
    return encode_le(UInt32, m.buffer, sbe_position(m), n)
end

@inline function skip_manufacturer!(m::CarDecoder)
    len = manufacturer_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return len
end

@inline function manufacturer(m::CarDecoder)
    len = manufacturer_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline manufacturer(m::CarDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, manufacturer(m))
@inline manufacturer(m::CarDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, manufacturer(m)); ntuple(i -> x[i], Val(N)))
@inline manufacturer(m::CarDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(manufacturer(m)))
@inline manufacturer(m::CarDecoder, ::Type{T}) where {T<:Symbol} = Symbol(manufacturer(m, StringView))
@inline manufacturer(m::CarDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, manufacturer(m))[]
@inline manufacturer(m::CarDecoder, ::Type{T}) where {T<:Nothing} = (skip_manufacturer!(m); nothing)

@inline function manufacturer_buffer!(m::CarEncoder, len)
    manufacturer_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function manufacturer!(m::CarEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    manufacturer_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function manufacturer!(m::CarEncoder, src::NTuple)
    len = sizeof(src)
    manufacturer_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function manufacturer!(m::CarEncoder, src::AbstractString)
    len = sizeof(src)
    manufacturer_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline manufacturer!(m::CarEncoder, src::Symbol) = manufacturer!(m, to_string(src))
@inline manufacturer!(m::CarEncoder, src::StaticString) = manufacturer!(m, Tuple(src))
@inline manufacturer!(m::CarEncoder, src::Real) = manufacturer!(m, Tuple(src))
@inline manufacturer!(m::CarEncoder, ::Nothing) = manufacturer_buffer!(m, 0)

function model_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

model_character_encoding(::Car) = "UTF-8"
model_character_encoding(::Type{<:Car}) = "UTF-8"
model_in_acting_version(m::Car) = sbe_acting_version(m) >= 0
model_id(::Car) = 19
model_id(::Type{<:Car}) = 19
model_header_length(::Car) = 4
model_header_length(::Type{<:Car}) = 4

@inline function model_length(m::Car)
    return decode_le(UInt32, m.buffer, sbe_position(m))
end

@inline function model_length!(m::CarEncoder, n)
    @boundscheck n > 1073741824 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 4 + n)
    return encode_le(UInt32, m.buffer, sbe_position(m), n)
end

@inline function skip_model!(m::CarDecoder)
    len = model_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return len
end

@inline function model(m::CarDecoder)
    len = model_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline model(m::CarDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, model(m))
@inline model(m::CarDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, model(m)); ntuple(i -> x[i], Val(N)))
@inline model(m::CarDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(model(m)))
@inline model(m::CarDecoder, ::Type{T}) where {T<:Symbol} = Symbol(model(m, StringView))
@inline model(m::CarDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, model(m))[]
@inline model(m::CarDecoder, ::Type{T}) where {T<:Nothing} = (skip_model!(m); nothing)

@inline function model_buffer!(m::CarEncoder, len)
    model_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function model!(m::CarEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    model_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function model!(m::CarEncoder, src::NTuple)
    len = sizeof(src)
    model_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function model!(m::CarEncoder, src::AbstractString)
    len = sizeof(src)
    model_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline model!(m::CarEncoder, src::Symbol) = model!(m, to_string(src))
@inline model!(m::CarEncoder, src::StaticString) = model!(m, Tuple(src))
@inline model!(m::CarEncoder, src::Real) = model!(m, Tuple(src))
@inline model!(m::CarEncoder, ::Nothing) = model_buffer!(m, 0)

function activationCode_meta_attribute(::Car, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end

activationCode_character_encoding(::Car) = "ASCII"
activationCode_character_encoding(::Type{<:Car}) = "ASCII"
activationCode_in_acting_version(m::Car) = sbe_acting_version(m) >= 0
activationCode_id(::Car) = 20
activationCode_id(::Type{<:Car}) = 20
activationCode_header_length(::Car) = 4
activationCode_header_length(::Type{<:Car}) = 4

@inline function activationCode_length(m::Car)
    return decode_le(UInt32, m.buffer, sbe_position(m))
end

@inline function activationCode_length!(m::CarEncoder, n)
    @boundscheck n > 1073741824 && throw(ArgumentError("length exceeds schema limit"))
    @boundscheck checkbounds(m.buffer, sbe_position(m) + 4 + n)
    return encode_le(UInt32, m.buffer, sbe_position(m), n)
end

@inline function skip_activationCode!(m::CarDecoder)
    len = activationCode_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return len
end

@inline function activationCode(m::CarDecoder)
    len = activationCode_length(m)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline activationCode(m::CarDecoder, ::Type{AbstractArray{T}}) where {T<:Real} = reinterpret(T, activationCode(m))
@inline activationCode(m::CarDecoder, ::Type{NTuple{N,T}}) where {N,T<:Real} = (x = reinterpret(T, activationCode(m)); ntuple(i -> x[i], Val(N)))
@inline activationCode(m::CarDecoder, ::Type{T}) where {T<:AbstractString} = StringView(rstrip_nul(activationCode(m)))
@inline activationCode(m::CarDecoder, ::Type{T}) where {T<:Symbol} = Symbol(activationCode(m, StringView))
@inline activationCode(m::CarDecoder, ::Type{T}) where {T<:Real} = reinterpret(T, activationCode(m))[]
@inline activationCode(m::CarDecoder, ::Type{T}) where {T<:Nothing} = (skip_activationCode!(m); nothing)

@inline function activationCode_buffer!(m::CarEncoder, len)
    activationCode_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    return view(m.buffer, pos+1:pos+len)
end

@inline function activationCode!(m::CarEncoder, src::AbstractArray)
    len = sizeof(eltype(src)) * length(src)
    activationCode_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(UInt8, src))
end

@inline function activationCode!(m::CarEncoder, src::NTuple)
    len = sizeof(src)
    activationCode_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, reinterpret(NTuple{len,UInt8}, src))
end

@inline function activationCode!(m::CarEncoder, src::AbstractString)
    len = sizeof(src)
    activationCode_length!(m, len)
    pos = sbe_position(m) + 4
    sbe_position!(m, pos + len)
    dest = view(m.buffer, pos+1:pos+len)
    copyto!(dest, codeunits(src))
end

@inline activationCode!(m::CarEncoder, src::Symbol) = activationCode!(m, to_string(src))
@inline activationCode!(m::CarEncoder, src::StaticString) = activationCode!(m, Tuple(src))
@inline activationCode!(m::CarEncoder, src::Real) = activationCode!(m, Tuple(src))
@inline activationCode!(m::CarEncoder, ::Nothing) = activationCode_buffer!(m, 0)

function show(io::IO, m::Car{T}) where {T}
    println(io, "Car view over a type $T")
    println(io, "SbeBlockLength: ", sbe_block_length(m))
    println(io, "SbeTemplateId:  ", sbe_template_id(m))
    println(io, "SbeSchemaId:    ", sbe_schema_id(m))
    println(io, "SbeSchemaVersion: ", sbe_schema_version(m))

    writer = CarDecoder(sbe_buffer(m), sbe_offset(m), Ref(0),
        sbe_block_length(m), sbe_schema_version(m))
    print(io, "serialNumber: ")
    print(io, serialNumber(writer))

    println(io)
    print(io, "modelYear: ")
    print(io, modelYear(writer))

    println(io)
    print(io, "available: ")
    print(io, available(writer))

    println(io)
    print(io, "code: ")
    print(io, code(writer))

    println(io)
    print(io, "someNumbers: ")
    print(io, someNumbers(writer))

    println(io)
    print(io, "vehicleCode: ")
    print(io, "\"")
    print(io, vehicleCode(writer, StringView))
    print(io, "\"")

    println(io)
    print(io, "extras: ")
    show(io, extras(writer))

    println(io)
    print(io, "discountedModel: ")
    print(io, discountedModel(writer))

    println(io)
    print(io, "engine: ")
    show(io, engine(writer))

    println(io)
    println(io, "FuelFigures:")
    for group in fuelFigures(writer)
        show(io, group)
        println(io)
    end
    println(io)
    println(io, "PerformanceFigures:")
    for group in performanceFigures(writer)
        show(io, group)
        println(io)
    end
    println(io)
    print(io, "manufacturer: ")
    print(io, manufacturer(writer, StringView))

    println(io)
    print(io, "model: ")
    print(io, model(writer, StringView))

    println(io)
    print(io, "activationCode: ")
    print(io, activationCode(writer, StringView))

    nothing
end

@inline function sbe_skip!(m::CarDecoder)
    sbe_rewind!(m)
    for group in fuelFigures(m)
        sbe_skip!(group)
    end
    for group in performanceFigures(m)
        sbe_skip!(group)
    end
    skip_manufacturer!(m)
    skip_model!(m)
    skip_activationCode!(m)
    return
end
