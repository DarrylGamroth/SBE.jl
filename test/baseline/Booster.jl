# Generated SBE (Simple Binary Encoding) message codec
# Code generated by SBE. DO NOT EDIT.

export Booster, BoosterDecoder, BoosterEncoder
struct Booster{T<:AbstractArray{UInt8}}
    buffer::T
    offset::Int64
    acting_version::UInt16
    function Booster(buffer::T, offset::Integer=0, acting_version::Integer=0) where {T}
        new{T}(buffer, offset, acting_version)
    end
end
const BoosterDecoder = Booster
const BoosterEncoder = Booster

sbe_buffer(m::Booster) = m.buffer
sbe_offset(m::Booster) = m.offset
sbe_acting_version(m::Booster) = m.acting_version
sbe_encoded_length(::Booster) = UInt16(0x2)
sbe_encoded_length(::Type{<:Booster}) = UInt16(0x2)
sbe_schema_id(::Booster) = UInt16(0x1)
sbe_schema_id(::Type{<:Booster}) = UInt16(0x1)
sbe_schema_version(::Booster) = UInt16(0x0)
sbe_schema_version(::Type{<:Booster}) = UInt16(0x0)
Base.sizeof(m::Booster) = sbe_encoded_length(m)

function Base.convert(::Type{<:AbstractArray{UInt8}}, m::BoosterEncoder)
    return view(m.buffer, m.offset+1:m.offset+sbe_encoded_length(m))
end

function boostType_meta_attribute(::Booster, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
boostType_id(::Booster) = UInt16(0xffff)
boostType_id(::Type{<:Booster}) = UInt16(0xffff)
boostType_since_version(::Booster) = UInt16(0x0)
boostType_since_version(::Type{<:Booster}) = UInt16(0x0)
boostType_in_acting_version(m::Booster) = sbe_acting_version(m) >= UInt16(0x0)
boostType_encoding_offset(::Booster) = 0
boostType_encoding_offset(::Type{<:Booster}) = 0
boostType_encoding_length(::Booster) = 1
boostType_encoding_length(::Type{<:Booster}) = 1
@inline function boostType(m::BoosterDecoder, ::Type{Integer})
    return decode_le(UInt8, m.buffer, m.offset + 0)
end
@inline function boostType(m::BoosterDecoder)
    return BoostType.SbeEnum(decode_le(UInt8, m.buffer, m.offset + 0))
end
@inline boostType!(m::BoosterEncoder, value::BoostType.SbeEnum) = encode_le(UInt8, m.buffer, m.offset + 0, UInt8(value))

function horsePower_meta_attribute(::Booster, meta_attribute)
    meta_attribute === :presence && return Symbol("required")
    return Symbol("")
end
horsePower_id(::Booster) = UInt16(0xffff)
horsePower_id(::Type{<:Booster}) = UInt16(0xffff)
horsePower_since_version(::Booster) = UInt16(0x0)
horsePower_since_version(::Type{<:Booster}) = UInt16(0x0)
horsePower_in_acting_version(m::Booster) = sbe_acting_version(m) >= UInt16(0x0)
horsePower_encoding_offset(::Booster) = 1
horsePower_encoding_offset(::Type{<:Booster}) = 1
horsePower_null_value(::Booster) = UInt8(0xff)
horsePower_null_value(::Type{<:Booster}) = UInt8(0xff)
horsePower_min_value(::Booster) = UInt8(0x0)
horsePower_min_value(::Type{<:Booster}) = UInt8(0x0)
horsePower_max_value(::Booster) = UInt8(0xfe)
horsePower_max_value(::Type{<:Booster}) = UInt8(0xfe)
horsePower_encoding_length(::Booster) = 1
horsePower_encoding_length(::Type{<:Booster}) = 1

@inline function horsePower(m::BoosterDecoder)
    return decode_le(UInt8, m.buffer, m.offset + 1)
end
@inline horsePower!(m::BoosterEncoder, value) = encode_le(UInt8, m.buffer, m.offset + 1, value)

function show(io::IO, writer::Booster{T}) where {T}
    println(io, "Booster view over a type $T")
    print(io, "BoostType: ")
    print(io, boostType(writer))

    println(io)
    print(io, "horsePower: ")
    print(io, horsePower(writer))

end
